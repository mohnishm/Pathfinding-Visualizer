{"version":3,"sources":["components/node.jsx","algorithms/helperFunctions.js","algorithms/dijkstras.js","components/drop-down.jsx","components/visualizer.jsx","algorithms/bfs.js","algorithms/dfs.js","App.js","serviceWorker.js","index.js"],"names":["Node","row","col","isStart","isFinish","isWall","onMouseDown","onMouseEnter","onMouseUp","extraClass","id","className","getUnvisitedNeighbors","node","grid","neighbors","push","length","filter","neighbor","isVisited","sortNodesByDistance","unvisitedNodes","sort","nodeA","nodeB","distance","updateUnvisitedNeighbors","unvisitedNeighbors","previousNode","DropDown","handleSubmit","handleReset","algoType","useRef","style","display","role","aria-label","onSubmit","e","preventDefault","ref","input","value","type","onClick","algorithms","startNode","finishNode","visitedNodesInOrder","nodes","getAllNodes","closestNode","shift","Infinity","currentNode","pop","Visualizer","props","state","mouseIsPressed","initialGrid","getInitialGrid","this","setState","newGrid","getNewGridWithWallToggled","nodesInShortestPathOrder","i","setTimeout","animateShortestPath","document","getElementById","algo","console","log","unshift","getNodesInShortestPathOrder","animateDijkstra","algorithm","visualize","handleResetBoard","map","rowId","key","nodeId","handleMouseDown","handleMouseEnter","handleMouseUp","React","Component","currentRow","createNode","slice","newNode","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.5cf6ef7d.chunk.js","sourcesContent":["import React from 'react';\nimport \"./node.css\";\n\nexport default function Node({ row, col, isStart, isFinish, isWall, onMouseDown, onMouseEnter, \n    onMouseUp }){\n    const extraClass = isStart ? 'isStart' : isFinish ? 'isFinish' : isWall ? 'isWall' : '';\n    return (\n        <div id={`node-${row}-${col}`} className={`node ${extraClass}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}\n        ></div>\n    );\n}","export function getAllNodes(grid){\n    const nodes = []\n    for (const row of grid) {\n        for(const node of row ){\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n\nexport function getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the algorithm is called.\nexport function getNodesInShortestPathOrder(finishNode) {\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n        nodesInShortestPathOrder.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}","import { getAllNodes, getUnvisitedNeighbors } from './helperFunctions';\n\n// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    const unvisitedNodes = getAllNodes(grid);\n    while (!!unvisitedNodes.length) {\n      sortNodesByDistance(unvisitedNodes);\n      const closestNode = unvisitedNodes.shift();\n      // If we encounter a wall, we skip it.\n      if (closestNode.isWall) continue;\n      // If the closest node is at a distance of infinity,\n      // we must be trapped and should therefore stop.\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n      if (closestNode === finishNode) return visitedNodesInOrder;\n      updateUnvisitedNeighbors(closestNode, grid);\n    }\n  }\n  \n  function sortNodesByDistance(unvisitedNodes) {\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n  }\n  \n  function updateUnvisitedNeighbors(node, grid) {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n      neighbor.distance = node.distance + 1;\n      neighbor.previousNode = node;\n    }\n  }\n  ","import React, { useRef } from 'react';\nimport \"../../node_modules/bulma/bulma.sass\";\n\nexport default function DropDown({ handleSubmit, handleReset }) {\n    let algoType = useRef(null);\n\n    return (\n        <nav style={{display:\"flex\", }} className=\"navbar is-link\" role=\"navigation\" aria-label=\"main navigation\">\n            <div className=\"navbar-brand\"><span className=\"icon\"><i className=\"fab fa-centercode\"></i></span></div>\n            <div className=\"navbar-menu\">\n                <div className=\"navbar-item\">\n                    <form onSubmit={(e) => {\n                        e.preventDefault();\n                    }}>\n                            <select className=\"navbar-link has-dropdown\" ref={(input) => algoType = input}> Algorithm\n                                <option className=\"navbar-item\" value=\"Dijkstras\">Dijkstra's</option>\n                                <option className=\"navbar-item\" value=\"BreadthFirst\">Breadth First Search</option>\n                                <option className=\"navbar-item\" value=\"DepthFirst\">Depth First Search</option>\n                            </select>\n                    </form>  \n                </div>\n                <div className=\"navbar-item\">\n                    <input className=\"button\" type=\"submit\" value=\"Submit\" onClick={() => handleSubmit(algoType.value)} />\n                </div>\n                <div className=\"navbar-item\">\n                    <input className=\"button\" type=\"submit\" value=\"Reset\" onClick={() => handleReset()} />\n                </div>\n            </div>\n        </nav>\n        \n    );\n}","import React from 'react';\nimport Node from './node';\nimport { dijkstra } from '../algorithms/dijkstras';\nimport { bfs } from '../algorithms/bfs';\nimport { dfs } from '../algorithms/dfs';\nimport { getNodesInShortestPathOrder } from '../algorithms/helperFunctions';\nimport './visualizer.css';\nimport DropDown from './drop-down';\n\nconst rows = 15;\nconst columns = 30;\nconst startRow = 7;\nconst startCol = 7;\nconst finishRow = 7;\nconst finishCol = 20;\n\nconst algorithms = {\n    'Dijkstras': dijkstra,\n    'BreadthFirst': bfs,\n    'DepthFirst': dfs,\n  };\n\nexport default class Visualizer extends React.Component {\n    \n    constructor(props){\n        super(props);\n        this.state = { grid : [], mouseIsPressed: false };\n    }\n    \n    componentDidMount(){\n        const initialGrid = getInitialGrid();\n        this.setState({ grid: initialGrid });\n    }\n\n    handleMouseDown(row, col){\n        const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n        this.setState({ grid: newGrid, mouseIsPressed: true});\n    }\n\n    handleMouseEnter(row, col){\n        if (!this.state.mouseIsPressed)\n            return;\n        const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n        this.setState({ grid: newGrid, mouseIsPressed: true});\n    }\n\n    handleMouseUp(){\n        this.setState({ mouseIsPressed: false});\n    }\n\n    animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n            if (i === visitedNodesInOrder.length) {\n                setTimeout(() => {\n                this.animateShortestPath(nodesInShortestPathOrder);\n                }, 10 * i);\n                return;\n            }\n            setTimeout(() => {\n                const node = visitedNodesInOrder[i];\n                document.getElementById(`node-${node.row}-${node.col}`).className =\n                'node isVisited';\n            }, 10 * i);\n        }\n    }\n    \n    animateShortestPath(nodesInShortestPathOrder) {\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n            setTimeout(() => {\n                const node = nodesInShortestPathOrder[i];\n                document.getElementById(`node-${node.row}-${node.col}`).className =\n                'node shortest-path';\n            }, 50 * i);\n        }\n    }\n    \n    visualize(algo) {\n        console.log(algo);\n        const { grid } = this.state;\n        const startNode = grid[startRow][startCol];\n        const finishNode = grid[finishRow][finishCol];\n        const visitedNodesInOrder = algorithms[algo](grid, startNode, finishNode);\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n        this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n    }\n\n    handleResetBoard() {\n        const grid = getInitialGrid()\n        for(const row of grid){\n            for(const node of row){\n                if(node.row === startRow && node.col === startCol){\n                    node.isStart = true;\n                }\n                else if(node.row === finishRow && node.col === finishCol){\n                    node.isFinish = true;\n                    \n                }\n                document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\n            }\n        }\n        document.getElementById(`node-${startRow}-${startCol}`).className = \n        'node isStart';\n        document.getElementById(`node-${finishRow}-${finishCol}`).className = \n        'node isFinish';\n        this.setState({ grid: grid });\n        console.log(this.props.algorithm)\n    }\n\n    render(){\n        return(\n            <>  \n                <DropDown handleSubmit={(algo) => this.visualize(algo)} \n                handleReset={() => this.handleResetBoard()} />\n                <div className=\"grid\">\n                    {this.state.grid.map((row, rowId) => \n                        <div key={rowId}>\n                            {row.map((node, nodeId) => \n                                <Node key={nodeId} \n                                row={node.row} \n                                col={node.col} \n                                isStart={node.isStart} \n                                isFinish={node.isFinish} \n                                isWall={node.isWall}\n                                mouseIsPressed={this.state.mouseIsPressed}\n                                onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                                onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\n                                onMouseUp={() => this.handleMouseUp()}></Node>\n                            )}\n                        </div>  \n                    )}\n                </div> \n            </>    \n        );\n    } \n}\n\nfunction getInitialGrid() {\n    const grid = [];\n    for(let row = 0; row < rows; row++){\n        const currentRow = [];\n        for(let col = 0; col < columns ; col++){\n            currentRow.push(createNode(row, col));\n        }\n        grid.push(currentRow);\n    }\n    return grid;\n}\n\nfunction createNode(row, col) {\n    return ({\n        row: row,\n        col: col,\n        isStart: row === startRow && col === startCol,\n        isFinish: row === finishRow && col === finishCol,\n        isWall: false,\n        isVisited: false,\n        previousNode: null,\n        distance: Infinity\n    });\n}\n\nfunction getNewGridWithWallToggled(grid, row, col) {\n    const newGrid = grid.slice();\n    const node = grid[row][col];\n    const newNode = {\n        ...node,\n        isWall: !node.isWall\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n}","import { getUnvisitedNeighbors } from './helperFunctions'\n\nexport function bfs(grid, startNode, finishNode) {\n    const unvisitedNodes = [];\n    const visitedNodesInOrder = [];\n    \n    startNode.isVisited = true;\n    unvisitedNodes.push(startNode);\n    visitedNodesInOrder.push(startNode);\n\n    while(!!unvisitedNodes.length){\n        let currentNode = unvisitedNodes.shift()\n\n        if(currentNode.isWall) continue;\n        if(currentNode === finishNode) return visitedNodesInOrder;\n        let unvisitedNeighbors = getUnvisitedNeighbors(currentNode, grid);\n\n        for(const neighbor of unvisitedNeighbors){\n            neighbor.isVisited = true;\n            neighbor.previousNode = currentNode;\n            unvisitedNodes.push(neighbor);\n            visitedNodesInOrder.push(neighbor);\n        }\n    }\n    return visitedNodesInOrder;\n}","import { getUnvisitedNeighbors } from \"./helperFunctions\";\n\nexport function dfs(grid, startNode, finishNode){\n    const unvisitedNodes = [];\n    const visitedNodesInOrder = [];\n    \n    startNode.isVisited = true;\n    \n    unvisitedNodes.push(startNode)\n    visitedNodesInOrder.push(startNode)\n\n    while(!!unvisitedNodes.length){\n        let currentNode = unvisitedNodes.pop();\n        \n        if(currentNode === finishNode) return visitedNodesInOrder;\n        if(currentNode.isWall) continue;\n        currentNode.isVisited = true;\n        visitedNodesInOrder.push(currentNode);\n        let unvisitedNeighbors = getUnvisitedNeighbors(currentNode, grid);\n\n        for (const neighbor of unvisitedNeighbors){\n            neighbor.previousNode = currentNode;\n            unvisitedNodes.push(neighbor);\n        }\n    }\n    return visitedNodesInOrder;\n}","import React from 'react';\nimport './App.css';\n// import DropDown from './components/drop-down';\nimport Visualizer from './components/visualizer';\n\nexport default class App extends React.Component {\n  render(){\n    return (\n      <div className=\"App\">\n        <Visualizer />\n      </div>\n    );\n  }\n}\n\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}